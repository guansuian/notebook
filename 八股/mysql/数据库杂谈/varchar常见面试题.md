

### 1. `VARCHAR` 与 `CHAR` 的区别（最基础）

- **长度特性**：**`VARCHAR` 是可变长度**的字符类型，按实际长度存储数据；**`CHAR` 是固定长度**的字符类型，定义多长就占多长空间。
- **空间利用**：如果存储的数据小于定义长度，`CHAR` 会在右侧用**空格填充**到指定长度，而 `VARCHAR` 仅占用实际字符所需的空间加上**额外的长度记录字节**。
- **存储开销**：`VARCHAR` 需要额外的 **1 到 2 个字节**来记录字符串的实际长度。
- **适用场景**：`CHAR` 适合存储长度非常接近或固定的数据（如 MD5、性别、身份证号）；`VARCHAR` 适合长度变化较大的字段（如地址、评论）。

### 2. `VARCHAR` 的最大长度是多少？如何计算？（高阶）

- **最大字节数**：`VARCHAR` 字段的最大长度理论上可以容纳 **65,535 个字节**。
- **实际限制**：实际上无法达到 65,535。首先，MySQL 需要 **1-2 个字节记录长度**；其次，若列定义为 `NULL`，还需要 **1 字节的 NULL 标识位**；此外，该长度是所有字段共享的，单行总长度有限制。
- **字符集影响**：最大长度受到字符集影响。例如使用 **`utf8mb4`** 字符集（每个字符占用 1-4 字节），`VARCHAR` 能存储的最大字符数大约只有 **16,383**（即 $65,532 / 4$）。

### 3. 如何优化长 `VARCHAR` 字段的查询效率？

- **前缀索引（Prefix Index）**：对于很长的 `VARCHAR` 字段（如邮箱、长 URL），直接建全列索引会很占空间且效率低，可以只对字符串的前几个字符建立**前缀索引**。
- **前缀索引缺点**：使用前缀索引后，MySQL 无法利用该索引进行 **`ORDER BY`** 或 **`GROUP BY`** 操作。
- **哈希索引优化**：对于极长的字符串查找，可以新增一个字段存储该字符串的 **CRC32 哈希值**，并对哈希值建索引，将字符串查找转化为整数查找。

### 4. `VARCHAR` 在 InnoDB 底层是如何存储的？

- **变长字段列表**：在 InnoDB 的行格式（如 Compact/Dynamic）中，行记录的头部包含一个**变长字段长度列表**，专门用来记录 `VARCHAR` 等变长字段的实际长度。
- **行溢出（Row Overflow）**：如果 `VARCHAR` 字段存入的数据过大（超过 16KB 页面承载范围），InnoDB 会发生“**行溢出**”，在原页面仅保留 20 字节的指针，将实际数据存储到专门的**溢出页**中。

### 5. 两个表关联，字段分别是 `CHAR(10)` 和 `VARCHAR(15)`，会影响性能吗？

- **类型匹配原则**：MySQL 只有在关联列的**类型和大小一致**时才能最有效地利用索引。
- **性能隐患**：如果长度不匹配（如一个是 10，一个是 15），可能会导致索引无法完全发挥作用。
- **优化建议**：面试中可以提到，在这种情况下应使用 `ALTER TABLE` 修改字段，使关联字段的**类型和长度保持一致**。

### 6. 为什么不推荐在 `WHERE` 子句中对 `VARCHAR` 列使用函数？

- **索引失效**：如果在 `VARCHAR` 类型的索引列上使用函数（如 `LOWER()` 或 `DATE_FORMAT()`），会导致 **索引失效**，触发全表扫描。
- **原理**：因为索引树是基于原始值构建的，函数运算会改变值，优化器无法在 B+ 树上进行快速查找。

这些问题涵盖了从存储细节到实战优化的各个层面，建议在面试时结合 **B+ 树的“矮胖”结构**以及 **I/O 成本**来回答为什么要优化 `VARCHAR` 的存储和检索。