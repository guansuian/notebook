# 1 什么是 MySQL
MySQL 是开源的关系型数据库，隶属于 Oracle 公司，是国内使用最广泛的数据库之一。我本地安装的是 8.3 版本。

# 2 MySQL 出现性能差的原因有哪些？
- SQL 写法问题：全表扫描、复杂 JOIN/子查询、未命中索引、返回列过多。
- 索引问题：缺失索引、低选择性索引、冗余索引、索引维护成本过高。
- 数据量与表结构：单表过大、冷热数据未分离、表设计不合理。
- 事务与锁：长事务、锁等待、死锁导致吞吐下降。
- 资源与配置：CPU/I/O 瓶颈、内存不足、参数配置不合理。
- 访问模式：热点读写、突发流量、缓存失效导致回源。

## 追问
1. 你提到可能是 SQL 复杂或全表扫描。请详细描述，在 Windows 环境下的生产系统中，你如何通过工具定位到那一跳特定的慢 SQL？除了 `EXPLAIN` 命令，你会观察哪些核心指标（Metric）来判定它是 CPU 密集型还是 I/O 密集型？
2. 你说添加索引能解决问题。如果现在是一个高频更新（High-frequency Update）的表，且 B+ 树索引已经导致了严重的页分裂（Page Split），你依然坚持加索引吗？如何通过 **覆盖索引（Covering Index）** 减少回表，从而在不增加索引数量的前提下提升 5 倍性能？
3. 引入 Redis 确实能降压，但如果发生了 **缓存击穿（Cache Breakdown）** 或 **缓存雪崩（Cache Avalanche）**，你的 MySQL 会瞬间宕机。请给出一个企业级的防御方案，并说明在 SpringBoot 中如何实现该逻辑。？

# 3 两张表怎么进行连接
可以通过内连接 `inner join` 、外连接 `outer join` 、交叉连接 `cross join` 来合并多个表的查询结果。

## 什么是内连接
内连接⽤于返回两个表中有匹配关系的⾏。假设有两张表，⽤户表和订单表，想查询有订单的⽤户，就可以使⽤内 连接 `users INNER JOIN orders` ，按照⽤户 ID 关联就⾏了。

```sql

SELECT users.name, orders.order_id FROM users INNER JOIN orders ON users.id = orders.user_id
```
只有那些在两个表中都存在 user_id 的记录才会出现在查询结果中。

## 什么是外连接
和内连接不同，外连接不仅返回两个表中匹配的⾏，还返回没有匹配的⾏⽤null来进行填充
外连接⼜分为左外连接 `left join` 和右外连接 `right join `。 
