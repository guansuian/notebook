# 问题1：考查对 BCrypt 结构的理解

**面试官：** “你提到盐（Salt）就藏在密文里。那如果黑客拿到了你的数据库（拖库成功），他一眼就能看到每一行记录里对应的盐。**既然盐已经公开了，它为什么还能起到保护作用？** 它的存在逻辑是什么？”

- **考察点：** 考查你是否理解“加盐”不是为了隐藏盐，而是为了**增加计算代价**和**消除通用性**。
    
- **满分回答要点：** 
1. 盐的作用是使彩虹表失效，黑客必须为每一个盐单独生成一套字典，成本呈指数级增长。 
2. BCrypt 带有工作因子（Cost），可以人为增加单次哈希的 CPU 耗时，防止黑客进行暴力穷举（Brute-force）。
3. [彩虹表](彩虹表.md)


# 问题2：考查对 Spring Security 的掌握

**面试官：** “在 Spring Security 中，`BCryptPasswordEncoder` 的 `matches` 方法是由于什么原因被设计出来的？**为什么我不能直接用 `encoder.encode(userInput)` 算出结果，然后用 `String.equals()` 去和数据库里的结果比对？**”

- **考察点：** 考查你是否知道 BCrypt 的**随机性**特质。
    
- **致命错误：** 如果你回答“因为加盐了”，这太笼统。
    
- **满分回答要点：** 
1. 每次 `encode` 都会生成新的随机盐。即使输入相同，产生的哈希值也不同，所以直接 `equals` 永远是 `false`。 
2. `matches` 方法内部逻辑是：先从数据库密文中解析出旧盐，再用旧盐对输入密码重算，最后比对。
3. 攻击者会计时攻击：`String.equals()`，它是发现第一个字母不对就返回。黑客可以通过毫秒级的响应差异，推算出你的密码哪一位是对的。所以必须要使用 `MessageDigest.isEqual()`，无论对错，它都会跑完所有位的比对，耗时恒定。

# 问题3：考查防御侧信道攻击

**面试官：** “在对比两个哈希字符串时，`String.equals()` 是逐个字符比对的，一旦发现字符不同就立即返回。这会导致黑客通过测量响应时间推算出密码位（这叫**计时攻击/Timing Attack**）。**你所使用的工具类是如何在代码层面防御这种攻击的？**”

- **考察点：** 这是区分“普通开发者”与“资深安全开发”的分水岭。
    
- **满分回答要点：** 
1. Spring Security 的 `MessageDigestAlgorithms.isEqual` 或相关工具类使用了 **Constant-time comparison (恒定时间比较)**。 
2. 无论密码匹配到哪一位失败，比对过程消耗的时间都是一样的，黑客无法通过时间差获取任何信息。
