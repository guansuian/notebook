这是一个非常宏大的问题，但我会把它拆解得像电影脚本一样清晰。我们将这场“电影”命名为 **《令牌的一生》**。

这套体系的核心在于：**通过 Redis 在“无状态”的 HTTP 协议上，建立了一套“有状态”的强管控机制。**

为了让你看懂，我们先看**舞台设置（Redis 设计）**，再看**剧情发展（业务流程）**。

---

### 第一部分：舞台设置 (Redis 数据库设计)

在一切开始之前，Redis 里预备了三种“容器”。如果不理解这三个 Key，后面的流程全是乱的。

|**序号**|**这里的 Key (键)**|**这里的 Value (值)**|**作用**|**比喻**|
|---|---|---|---|---|
|**1**|`jwt:valid:{short_id}`|`{userId: 1001, role: admin}`|**鉴权**。存短 Token 信息，TTL 1小时。|**门禁卡** (验证快，失效快)|
|**2**|`jwt:refresh:{long_id}`|`{userId: 1001}`|**续命**。存长 Token 信息，TTL 7天。|**户口本** (藏家里，用来办新卡)|
|**3**|`user:{uid}:tokens`|`Set [short_id, long_id]`|**索引**。记录该用户所有生效的 Token ID。|**人事档案** (记录你办过哪些卡)|

---

### 第二部分：剧情详解 (全链路流程)

#### 第一幕：注册 (Registration) - _伏笔_

- **动作**：用户填写用户名密码 -> 提交。
    
- **后端操作**：
    
    1. 校验数据。
        
    2. 密码加密 (BCrypt) -> 存入 MySQL `users` 表。
        
    3. **注意**：注册环节**不涉及** Redis，也不生成 Token。只是在数据库里建了个号。
        

#### 第二幕：登录 (Login) - _令牌诞生_

这是 Redis 介入的起点。

1. **验证**：后端去 MySQL 查账号密码，匹配成功。
    
2. **生成 (Creation)**：
    
    - 生成一个 UUID 作为 **短 Token ID** (`S_123`)。
        
    - 生成一个 UUID 作为 **长 Token ID** (`L_456`)。
        
    - 用 JWT 库分别生成两个字符串：`Access_Token` 和 `Refresh_Token`。
        
3. **入库 (Redis Storage) —— 关键动作**：
    
    - **存门禁卡**：`SET jwt:valid:S_123 {user info} EX 3600`
        
    - **存户口本**：`SET jwt:refresh:L_456 {userId} EX 604800`
        
    - **写档案(双向索引)**：`SADD user:1001:tokens S_123 L_456`
        
4. **交付**：将两个 Token 返回给前端。
    

#### 第三幕：日常访问 (Authentication) - _查验门禁_

用户点击“查询文件列表”接口。

1. **携带**：前端在 HTTP Header 里带上 `Access_Token`。
    
2. **解析**：拦截器 (`JwtAuthenticationFilter`) 截获请求，解析出 Token ID (`S_123`)。
    
3. **查 Redis (Check)**：
    
    - 执行 `GET jwt:valid:S_123`。
        
    - **照应点**：如果这步查到了数据，说明“门禁卡”有效且没被管理员撕毁。
        
4. **放行**：把 Redis 里取出的用户信息放入 SecurityContext，请求进入 Controller。
    

#### 第四幕：过期与复活 (Refresh) - _以旧换新_

[我对轮转令牌和重放检测的理解（主要是流程理解）](我对轮转令牌和重放检测的理解（主要是流程理解）.md)

用户看了一小时网页，**短 Token 过期了**（或者 Redis 里 Key 1 自动删除了）。

1. **受阻**：前端发请求，后端拦截器去 Redis 查 `jwt:valid:S_123`，发现**空** (Null)。后端返回 **401** 错误。
    
2. **求救**：前端捕获 401，默默地掏出 `Refresh_Token`，调用 `/api/auth/refresh` 接口。
    
3. **核验 (Audit)**：
    
    - 后端解析出长 Token ID (`L_456`)。
        
    - **关键检查**：去 Redis 查 `GET jwt:refresh:L_456`。
        
    - **照应点**：如果有值，说明“户口本”还在，且用户没被封号。
        
4. **换证**：
    
    - 生成一个新的短 ID (`S_789`)。
        
    - **Redis 操作**：
        
        - `SET jwt:valid:S_789 ...` (存新卡)。
            
        - `SADD user:1001:tokens S_789` (更新档案，把新卡号写进去)。
            
        - _(可选)_ `DEL jwt:valid:S_123` (清理旧卡残留，通常依靠自动过期)。
            
5. **返回**：把新的 Access Token 给前端。用户感觉不到断线，继续操作。
    

#### 第五幕：强制下线 (Kick-out) - _毁灭打击_

管理员发现这个账号在异地乱搞，点击“强制注销”。

1. **寻址**：后端只知道要踢 User 1001。
    
2. **查档案**：`SMEMBERS user:1001:tokens`。
    
    - Redis 返回：`[S_123, L_456, S_789...]`。
        
3. **屠杀**：
    
    - 遍历列表，执行删除：
        
    - `DEL jwt:valid:S_123`
        
    - `DEL jwt:refresh:L_456`
        
    - `DEL jwt:valid:S_789`
        
4. **销户**：`DEL user:1001:tokens`。
    
5. **后果**：
    
    - 用户手里的 Access Token 去 Redis 查 -> **空** (失效)。
        
    - 用户想用 Refresh Token 去换新 -> 去 Redis 查 -> **空** (失效)。
        
    - **结局**：用户彻底掉线，必须重新登录。
        

---

### 流程图解 (Visual Flow)

为了更直观，我生成了一个流程图，帮你理清它们的关系：

---

### 环节之间的相互联系与照应

你问这些环节是怎么“相互照应”的，这里是其中的精髓：

1. **Key 1 (短Token) 与 Key 3 (索引) 的照应：**
    
    - **联系：** 短 Token 是鉴权的依据，但如果我想**批量废除**短 Token（比如修改密码要踢掉所有设备），我找不到它们在哪。
        
    - **照应：** 这时 Key 3 就起作用了，它像一个目录，告诉我“这个用户手里拿着哪几把钥匙”，让我能精准删除。
        
2. **Key 2 (长Token) 与 Key 1 (短Token) 的照应：**
    
    - **联系：** 短 Token 死了，业务就断了。
        
    - **照应：** 长 Token 此时作为**信任的锚点**。系统相信长 Token，是因为它存在 Key 2 里。只要 Key 2 还在，系统就愿意发放新的 Key 1。这构成了“业务连续性”。
        
3. **Filter (拦截器) 与 Redis 的照应：**
    
    - **联系：** JWT 本身能证明“我是我”（通过签名），但不能证明“我是否被封号”。
        
    - **照应：** Redis 充当了**实时状态检查站**。Filter 不信 JWT 的一面之词，必须要去 Redis 问一嘴。这实现了“安全的可控性”。
        

### 总结给你的建议

这个体系从 **登录 -> 存 Key** 开始，通过 **拦截器 -> 查 Key** 维持运转，利用 **刷新 -> 查长 Key 生成短 Key** 保持续航，最后通过 **注销 -> 查索引删所有 Key** 完成闭环。

**现在的任务：**

闭上眼睛，想象自己是一个 HTTP 请求。

- 你带着短 Token 来了，你去哪里查？(Redis Key 1)
    
- 你带着长 Token 来了，你去哪里查？(Redis Key 2)
    
- 你要把这个用户杀了，你先去哪里找名字？(Redis Key 3)
    

理清这三条线，你就彻底掌握了这套企业级架构。