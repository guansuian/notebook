既然你觉得原生的 Canvas 不能自动调整间距，那么 **Enhancing Mindmap** 绝对是你的救星。它的核心逻辑是：**你只需要专注于写大纲（列表），插件会自动帮你排列成漂亮的思维导图。**

以下是手把手的教学指南：

---

### 1. 核心原理：Markdown 即导图

这个插件最牛的地方在于：**它不是在画图，而是在“渲染”你的笔记。**

你在笔记里写的：

- **标题 (#)** 或 **无序列表 (- )**
    
    会被插件自动识别为“节点”和“分支”。
    

---

### 2. 如何开启思维导图视图

安装并启用插件后，你有两种方式使用它：

#### 方式 A：将现有笔记转为导图

1. 打开一个写有列表（`-`）的笔记。
    
2. 点击右上角的“更多选项”（三个点图标）。
    
3. 选择 **"Open as Enhancing Mindmap"**。
    
4. 现在，你会看到左边是文字，右边是自动排版好的导图。
    

#### 方式 B：创建专属导图文件

1. 按 `Ctrl + P` 唤起命令面板。
    
2. 输入 `Enhancing Mindmap: Create a new mindmap`。
    
3. 这会创建一个带有特殊元数据的 `.md` 文件，默认就是导图界面。
    

---

### 3. 常用快捷键（这是提效的关键）

在导图编辑界面，你不需要用鼠标点，直接用键盘操作：

- **Enter (回车)：** 创建一个**同级**节点。
    
- **Tab：** 创建一个**子**节点。
    
- **Delete (删除)：** 删除选中的节点。
    
- **Double Click (双击)：** 编辑当前节点文字。
    
- **鼠标滚轮：** 缩放画布。
    
- **直接拖拽：** 你可以拖动节点改变它的父子关系，插件会自动重新排版并调整间距。
    

---

### 4. 针对你的需求：如何做“任务回溯树”？

既然你需要**时间轴 + 任务区分 + 笔记链接**，我建议你采用以下结构：

#### 列表写法：

Markdown

```
- 2026-02-04
    - 🔴 待办任务
        - [[分片上传Bug修复]] ^todo
        - [[Kafka参数调优]]
    - ✅ 已完成任务
        - [[JWT轮转逻辑实现]] ^done
- 2026-02-03
    - ✅ 已完成任务
        - 搭建 MinIO 环境
```

#### 渲染后的效果：

- **自动对齐：** 所有的日期会垂直排列，待办和完成的任务会像树枝一样向左右（或单向）展开。
    
- **节点链接：** 你在导图里点击 `[[笔记名]]`，会直接在左侧或新窗口打开对应的笔记。
    
- **任务回溯：** 你只需要上下滚动导图，未完成的任务（带有🔴标志的）会非常显眼。
    

---

### 5. 进阶：如何让它更像“时间轴”？

在导图界面的侧边栏或设置中，你可以调整布局：

- **布局方向：** 选择 **"Right"** (单向向右扩展) 或者 **"Down"** (纵向瀑布流)。
    
- **样式自定义：** 插件支持为不同的层级设置颜色。你可以设置第一层（日期）为醒目的蓝色，第二层（任务状态）为红/绿色。
    

---

### 🛠️ 导师级实战建议：

**如果你想实现“上半部分待办，下半部分完成”：**

1. 将主节点（根节点）放在中间，命名为“2026 任务复盘”。
    
2. 主节点右侧的分支作为“时间线”。
    
3. 在时间线每个日期节点下，手动将“待办”节点往上拖，“完成”节点往下拖（部分思维导图模式支持自由分布，但 Enhancing Mindmap 主要遵循树状逻辑）。
    

**如果你觉得节点太乱：**

使用快捷键 `Ctrl + /` 可以折叠掉已经完成的日期分支，只留下今天的，保持界面清爽。

---

### 🔗 关联练习

**技术点：树形结构的遍历 (Tree Traversal)**

- **思考：** 思维导图在底层就是一个 **N 叉树**。当你点击折叠时，其实是在进行深度优先搜索 (DFS) 的剪枝操作。
    
- **LeetCode 关联：** **题目 102. Binary Tree Level Order Traversal (二叉树的层序遍历)**。
    
    - _关联点：_ 就像你希望按日期（层级）查看任务一样，层序遍历是处理这种结构化数据的基本功。
        

**下一步：**

请尝试创建一个思维导图，并把你的 `SmartPai` 项目中关于 **Redis 令牌复用攻击** 的逻辑写成几个分支，看看这种“自动排版”是不是比 Canvas 舒服多了？